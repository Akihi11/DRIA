### **状态评估表（部分）：开发规范文档**

#### 1.** 概述**

**本模块的核心逻辑是“\*\***一票否决\**”。它会根据 JSON 配置，对*整个*试验数据流进行“地毯式”扫描。对每一个评估项，它都先假设结论为“是”（通过），然后去数据里寻找任何一个“失败”的证据。只要失败条件在*任何*时刻被触发了*哪怕一次\*，该项的最终结论就被永久地翻转为“否”（不通过） 。

- **输入**：一个 `reportConfig.json` 配置文件（使用你设计的 `statusEval`数组结构）。
- **[cite**\_**start]\*\***处理\**：一个“扫描器”（Scanner）。它会为 JSON 中除 `functional_result`之外的*所有\*评估项初始化“通过”状态，然后逐点扫描数据，寻找推翻这个状态的“失败”证据 。
- **[cite**\_**start]\*\***输出\*\*：一个 Excel 文件。严格按照 JSON 中 `evaluations`数组的顺序，生成三列：“评估项目”、“评估内容”、“评估结论” 。

#### 2.** 配置模块 (JSON 结构设计)**

**配置模块（前端或配置生成器）需要执行以下操作：**

1. **多选**：让用户从“压力传感器状态”、“喘振”、“电压/电流”、“流量”、“超温”、“超转”（以及那几个我们暂时跳过的）中多选要评估的项目。
2. **配置**：根据用户的选择，*按顺序*在 JSON 的 `evaluations`数组中生成评估对象。
3. **[cite**\_**start]\*\***默认值\*\*：为每个评估项的 `condition(s)`填入任务书（`S1`）中规定的默认值（例如 `statistic: "平均值"`, `duration: 1`, `logic: ">"`, `threshold: 100`） 。
4. **自然语言修改**：允许用户通过自然语言修改这些默认值。

##### 配置文件 (reportConfig.json) 结构

**这是基于你的设计，并结合任务书（**`S1`）中对多通道（压力、电压、流量）要求的最终 JSON 结构：

```
 {
   "statusEval": {
     "evaluations": [
       {
         "item": "pressureStatus",
         "assessmentName": "压力传感器状态评估",
         "assessmentContent": "压力传感器状态评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           {
             "channel": "[默认通道1]",
             "statistic": "平均值",
             "duration": 1,
             "logic": ">",
             "threshold": 100
           },
           {
             "channel": "[默认通道2]",
             "statistic": "平均值",
             "duration": 1,
             "logic": ">",
             "threshold": 100
           }
         ]
       },
       {
         "item": "surge",
         "assessmentName": "喘振评估",
         "assessmentContent": "喘振评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           {
             "channel": "[默认通道]",
             "statistic": "difference",
             "duration": 10,
             "logic": ">",
             "threshold": 100
           }
         ]
       },
       {
         "item": "voltageCurrent",
         "assessmentName": "电压/电流评估",
         "assessmentContent": "电压/电流评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           { "channel": "[默认A]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 },
           { "channel": "[默认B]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 },
           { "channel": "[默认C]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 }
         ]
       },
       {
         "item": "flow",
         "assessmentName": "流量评估",
         "assessmentContent": "流量评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           { "channel": "[默认X]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 },
           { "channel": "[默认Y]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 }
         ]
       },
       {
         "item": "overTemp",
         "assessmentName": "超温评估",
         "assessmentContent": "超温评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           { "channel": "[默认通道]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 }
         ]
       },
       {
         "item": "overSpeed",
         "assessmentName": "超转评估",
         "assessmentContent": "超转评估内容（可编辑）",
         "type": "continuous_check",
         "conditionLogic": "AND",
         "conditions": [
           { "channel": "[默认通道]", "statistic": "平均值", "duration": 1, "logic": ">", "threshold": 100 }
         ]
       }
     ]
   }
 }
```

##### 字段说明

- `item` (String): 评估项的唯一 ID，用于计算模块在 `results`字典中寻址。
- **[cite**\_**start]**`assessmentName` (String): 评估项的显示名称，用于 Excel 的第一列“评估项目” 。
- **[cite**\_**start]**`assessmentContent` (String): 评估项的描述，用于 Excel 的第二列“评估内容”，这个值应允许用户修改 。
- `type` (String):
  - `"functional_result"`: (我们这次跳过)
  - **[cite**\_**start]**`"continuous_check"`: 扫描整个数据流。我把你 JSON 里的 `event_check`和 `continuous_check`统一了，因为它们的*计算逻辑*（扫描所有数据 ）是一样的。
- **[cite**\_**start]**`conditionLogic` (String): 多个 `conditions`之间的组合逻辑。根据任务书，这总是 `"AND"` 。
- `conditions` (Array): **失败条件**的列表。
- `statistic` (String):
  - **[cite**\_**start]可选: **`"平均值"`, `"最大值"`, `"最小值"`, `"有效值"`, `"瞬时值"` 。
  - **[cite**\_**start]\*\***特殊值\*\*: 我建议用 `"difference"`来代表“喘振”的特殊算法（瞬时值减去 `duration`秒前的瞬时值） 。
- `duration` (Number): 统计时长或差值时长。

#### 3.** 计算模块实现逻辑**

##### 3.1. 初始化

1. **读取配置**：解析 `reportConfig.json` 文件。
2. **准备结果字典**：创建一个字典，`results = {}`。
3. **初始化结论**：遍历 `config.statusEval.evaluations`数组，将*每一个*评估项（`item.item`）的结论**初始化为 `'是'`**（通过）。
4. **准备滑动窗口**：遍历 `evaluations`数组。如果 `type == "continuous_check"`，就再遍历它的 `conditions`数组，根据所有需要的 `channel`, `statistic`, `duration`初始化 `SlidingWindow`计算器。

##### 3.2. 数据处理循环 (逐点扫描)

```
 # 循环处理每一个数据点
 for timestamp, data_point in data_stream:
 
     # 1. 统一更新所有滑动窗口
     _update_all_windows(timestamp, data_point)
 
     # 2. 遍历 *配置* 中的所有评估项 (为了保持顺序)
     for item in config.statusEval.evaluations:
 
         # 如果是表2的任务，跳过 (我们这次不实现)
         if item.type == "functional_result":
             continue
 
         item_id = item.item # 比如 "pressureStatus"
 
         # 优化：如果已经失败了，就没必要在这个数据点上再算了
         if results[item_id] == "否":
             continue
 
         # --- 开始检查 "continuous_check" ---
 
         # 这是一个 "失败条件" 列表
         condition_results = []
 
         for condition in item.conditions:
             # 检查这个单独的条件 (比如 "Ng > 100") 是否为 True
             is_met = evaluate_failure_condition(condition, data_point)
             condition_results.append(is_met)
 
         # 组合逻辑 (根据任务书，这里总是 "AND" 逻辑)
         # all() 函数：[True, True, True] -> True
         failure_is_met = all(condition_results)
 
         if failure_is_met:
             # 核心逻辑：一票否决
             results[item_id] = "否"
             logger.info(f"评估项 [{item.assessmentName}] 在 T={timestamp:.3f}s 触发失败")
 
 # --- 循环结束 ---
 # 3. 导出结果
 export_assessment_excel(results, config.statusEval.evaluations)
```

##### 3.3. 辅助函数 `evaluate_failure_condition`

**这个函数和** `turn_170`里的一样，它只管计算一个条件是否满足。

```
 def evaluate_failure_condition(condition_config: Dict, data_point: Dict) -> bool:
     """
     计算单个“失败条件”是否为 True
     """
     channel = condition_config['channel']
     statistic = condition_config['statistic']
     duration = condition_config['duration']
     logic = condition_config['logic']
     threshold = condition_config['threshold']
 
     value_to_check = None
 
     if statistic == "difference":
         # 喘振逻辑
         key = f"diff_{channel}_{duration}s"
         window = difference_windows[key]
         current_val = data_point[channel]
         oldest_val = window.get_oldest_value()
         if oldest_val is None:
             return False # 窗口未满，不算失败
         value_to_check = current_val - oldest_val
 
     elif statistic == "瞬时值":
         value_to_check = data_point[channel]
 
     else:
         # 平均值, 最大值, 最小值, 有效值
         key = f"{statistic}_{channel}_{duration}s"
         window = windows[key]
         value_to_check = window.calculate_statistic()
         if value_to_check is None:
             return False # 窗口未满，不算失败
 
     # 评估逻辑 (e.g., "是否 2001.2 > 2000 ?")
     return evaluate_logic(value_to_check, logic, threshold)
```

##### 3.4. 导出 (export***assessment*****excel)**

**导出函数必须遍历\***原始的配置数组\*，以保证 Excel 中的顺序与用户配置的顺序一致。

1. **遍历 **`config.statusEval.evaluations` 数组。
2. **对于数组中的每一个 **`item`：
3. **[cite**\_**start]\*\***第一列（评估项目）\*\*: 写入 `item.assessmentName`（例如 "压力传感器状态评估"） 。
4. **[cite**\_**start]\*\***第二列（评估内容）\*\*: 写入 `item.assessmentContent` 。
5. **[cite**\_**start]\*\***第三列（评估结论）\*\*: 写入 `results[item.item]` 的值（即 `'是'` 或 `'否'`） 。
