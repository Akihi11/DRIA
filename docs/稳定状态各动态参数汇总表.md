### 稳定状态各动态参数汇总表



#### 1. 概述

本模块的功能是根据用户定义的触发条件，在试验数据流中抓取满足条件时刻的快照。

- **输入**：一个 `reportConfig.json` 配置文件，定义了要抓取的通道和触发规则。

- **处理**：计算模块读取此 JSON，逐点分析时序数据流。

- **输出**：一个 Excel 文件。当触发条件满足时，将该时刻的“绝对时间”和所有“显示参数通道”的“瞬时值”写入 Excel 表格的一行。表格下方还需附带一个折线图。

    

#### 2. JSON 配置文件结构

计算模块依赖一个 JSON 文件来获取所有配置。以下是该 JSON 文件的标准结构和字段说明。

```json
{
  "reportConfig": {
    "reportType": "StableStateSummary",
    "displayChannels": [
      "Ng",
      "Np",
      "通道A",
      "通道B"
    ],
    "triggerLogic": {
      "combination": "AND",
      "condition1": {
        "enabled": true,
        "channel": "Np",
        "statistic": "Average",
        "duration_sec": 10,
        "logic": ">",
        "threshold": 8000
      },
      "condition2": {
        "enabled": false,
        "channel": "Ng",
        "statistic": "RateOfChange",
        "duration_sec": 1,
        "logic": "<",
        "threshold": 100
      }
    }
  }
}
```



##### 字段说明

- `reportConfig.reportType` (String):

    - **含义**：报表类型标识。固定为 `"StableStateSummary"`。
    - **用途**：供计算引擎路由到本模块。

- `reportConfig.displayChannels` (Array<String>):

    - **含义**：用户希望在最终 Excel 报表中看到的通道列表 。
    - **用途**：计算模块在触发时，会抓取此列表中所有通道的瞬时值。Excel 的表头将是 `["时间"] + displayChannels`。
    - **源文档规则**：此列表来自上传文件的“所有原始通道（包括转速）”。

- `reportConfig.triggerLogic.combination` (String):

    - **含义**：定义两个条件的组合方式。
    - **可选值**：
        - `"Cond1_Only"`：仅使用条件一。
        - `"Cond2_Only"`：仅使用条件二。
        - `"AND"`：两个条件必须同时满足 。
    - **源文档规则**：“若都设置了，则采用两个条件均满足才生效的逻辑” 。

- `reportConfig.triggerLogic.condition1` (Object):

    - **含义**：定义了“条件一”（统计型）的所有参数 。

    - `enabled` (Boolean)：是否启用此条件。

    - `channel` (String)：用于计算的通道名称。必须是“转速通道”之一。

    - `statistic` (String)：统计类型。可选值：`"Average"` (平均值), `"Max"` (最大值), `"Min"` (最小值), `"RMS"` (有效值)。

    - `duration_sec` (Number)：统计时长（秒）。必须在 0.1s ~ 50s 之间。

    - `logic` (String)：判断逻辑。可选值：`">"` 或 `"<"` 。

    - `threshold` (Number)：判断阈值。

    - **源文档默认值**：`statistic` 默认为 "Average" ，`duration_sec` 默认 1s ，`logic` 默认 ">" ，`threshold` 默认 100。

        

- `reportConfig.triggerLogic.condition2` (Object):

    - **含义**：定义了“条件二”（变化率型）的所有参数。
    - `enabled` (Boolean)：是否启用此条件。
    - `channel` (String)：用于计算的通道名称。必须是“转速通道”之一。
    - `statistic` (String)：**此字段固定为 `"RateOfChange"`**。
    - `duration_sec` (Number)：统计时长（秒）。必须在 0.1s ~ 50s 之间。
    - `logic` (String)：判断逻辑。可选值：`">"` 或 `"<"` 。
    - `threshold` (Number)：判断阈值。
    - **源文档规则**：条件二的算法固定为“幅值变化率”，即在 `duration_sec` 内的 `(最大值 - 最小值)`。



#### 3. 计算模块实现逻辑

计算模块读取上述 JSON 配置文件后，开始处理时序数据流。

##### 3.1. 初始化

1. **读取配置**：解析 `reportConfig.json` 文件。

2. **准备输出**：创建 Excel 工作簿 (Workbook) 和工作表 (Worksheet)。

3. **写入表头**：在工作表的第一行写入 `["时间"]`，然后追加 `reportConfig.displayChannels` 列表中的所有通道名称。

4. **创建缓冲区**：

    - 如果 `condition1.enabled` 为 true，为其 `channel` 创建一个数据缓冲区（推荐使用 `Deque` 或双端队列），`window_cond1`。
    - 如果 `condition2.enabled` 为 true，为其 `channel` 创建一个数据缓冲区，`window_cond2`。

5. **初始化状态变量**：

    ```python
    cond1_last_state = FALSE
    cond2_last_state = FALSE
    
    // 专门用于条件二的特殊逻辑
    cond2_last_recorded_value = NULL // 上次记录的变化率的值
    cond2_last_recorded_time = 0     // 上次记录变化率的时间
    ```



##### 3.2. 数据处理循环（核心逻辑）

模块将逐个数据点 `(T_now, data_point)` 进行处理：

```python
while (data_point = get_next_data_point()):
    
    T_now = data_point.timestamp
    cond1_met = FALSE
    cond2_met = FALSE

    // --- A. 更新条件一窗口并计算 ---
    if (config.condition1.enabled):
        // 1. 移除窗口左侧的过期数据
        //    (移除 window_cond1 队首所有 timestamp <= (T_now - config.condition1.duration_sec) 的数据)
        // 2. 将新数据 (T_now, data_point[config.condition1.channel]) 加入 window_cond1 队尾
        
        // 3. 计算统计值
        //    switch (config.condition1.statistic):
        //      case "Average": current_stat_cond1 = calculate_average(window_cond1) 
        //      case "Max": current_stat_cond1 = find_max_value(window_cond1) 
        //      case "Min": current_stat_cond1 = find_min_value(window_cond1) 
        //      case "RMS": current_stat_cond1 = calculate_rms(window_cond1) 
        
        // 4. 判断条件
        //    cond1_met = (current_stat_cond1 [config.condition1.logic] config.condition1.threshold) 

    // --- B. 更新条件二窗口并计算 ---
    if (config.condition2.enabled):
        // 1. 移除窗口左侧的过期数据 (同上)
        // 2. 将新数据 (T_now, data_point[config.condition2.channel]) 加入 window_cond2 队尾
        
        // 3. 计算统计值 (固定为变化率) 
        current_max_cond2 = find_max_value(window_cond2)
        current_min_cond2 = find_min_value(window_cond2)
        current_change_cond2 = current_max_cond2 - current_min_cond2 
        
        // 4. 判断条件
        //    cond2_met = (current_change_cond2 [config.condition2.logic] config.condition2.threshold) 

    // --- C. 组合最终触发条件 ---
    final_trigger = FALSE
    switch (config.triggerLogic.combination):
        case "Cond1_Only":
            final_trigger = cond1_met
        case "Cond2_Only":
            final_trigger = cond2_met
        case "AND":
            final_trigger = (cond1_met AND cond2_met) 

    // --- D. 判断是否执行记录动作 (关键) ---
    do_record = FALSE
    
    if (final_trigger == TRUE):
        
        // 检查触发条件是否涉及“条件二”
        uses_Condition_2 = (config.triggerLogic.combination == "Cond2_Only" OR config.triggerLogic.combination == "AND")
        
        if (uses_Condition_2):
            // 逻辑 B：处理条件二（变化率）的特殊10分钟规则 
            has_value_changed = (current_change_cond2 != cond2_last_recorded_value)
            is_time_up = (T_now - cond2_last_recorded_time > 10 * 60) // 10分钟 
            
            if (has_value_changed OR is_time_up):
                do_record = TRUE
                // 记录当前状态，用于下次比较
                cond2_last_recorded_value = current_change_cond2
                cond2_last_recorded_time = T_now
        
        else:
            // 逻辑 A：处理条件一（普通统计型）
            // 仅在状态从 False -> True 的“上升沿”记录一次
            if (cond1_last_state == FALSE):
                do_record = TRUE
    
    // --- E. 执行记录 ---
    if (do_record == TRUE):
        
        new_row = []
        new_row.append(T_now) // 记录绝对时间 
        
        // 遍历配置好的表头
        for channel_name in config.displayChannels:
            // 抓取 *此刻* 的瞬时值
            new_row.append(data_point[channel_name]) 
        
        // 将 new_row 写入 Excel 工作表
    
    // --- F. 更新上一轮的状态 ---
    cond1_last_state = cond1_met
    cond2_last_state = cond2_met

// --- G. 循环结束 ---
// 保存 Excel 文件
```



##### 3.3. 图表生成

数据写入 Excel 后，模块还需在同一工作表（或新工作表）中生成一个图表。

- **图表类型**：散点图，点与点之间用折线连接。

- **X轴**：使用 Excel 表格中的“时间”列数据 28。

- **Y轴**：使用表格中 `displayChannels` 对应的所有数据列 29。

- **Y轴要求**：必须采用“非公用Y轴形式” 30。

    

    